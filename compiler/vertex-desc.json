[
  {
    "comment": "artificial op that represents a part of code that we failed to parse",
    "name": "op_err",
    "base_name": "meta_op_base"
  },
  {
    "name": "meta_op_base"
  },
  {
    "comment": "a base type for all unary operators: <op>expr(); or expr()<op>",
    "sons": {
      "expr": 0
    },
    "name": "meta_op_unary",
    "base_name": "meta_op_base",
    "props": {
      "fixity": "left_opp"
    }
  },
  {
    "comment": "a base type for all binary operators: lhs() <op> rhs()",
    "sons": {
      "lhs": 0,
      "rhs": 1
    },
    "name": "meta_op_binary",
    "base_name": "meta_op_base",
    "props": {
      "fixity": "left_opp"
    }
  },
  {
    "name": "meta_op_varg",
    "base_name": "meta_op_base",
    "ranges": {
      "args": [
        0,
        0
      ]
    }
  },
  {
    "comment": "op that holds a function params and its body",
    "sons": {
      "param_list": {
        "id": 0,
        "type": "op_func_param_list"
      },
      "cmd": {
        "id": 1,
        "type": "op_seq"
      }
    },
    "name": "op_function",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "function"
    },
    "extra_fields": {
      "func_id": {
        "type": "FunctionPtr",
        "default": "{}"
      }
    }
  },
  {
    "comment": "contains a reference to a lambda (inserted in gentree instead of a lambda)",
    "name": "op_lambda",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "lambda"
    },
    "extra_fields": {
      "func_id": {
        "type": "FunctionPtr",
        "default": "{}"
      },
      "lambda_class": {
        "type": "ClassPtr",
        "default": "{}"
      }
    }
  },
  {
    "comment": "a base type for all loops (and switch, which is apparently a loop in PHP)",
    "name": "meta_op_cycle",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "cycle_op"
    },
    "extra_fields": {
      "break_label_id": {
        "type": "int",
        "default": 0
      },
      "continue_label_id": {
        "type": "int",
        "default": 0
      }
    }
  },
  {
    "comment": "a base type for op_isset and op_unset",
    "name": "meta_op_xset",
    "base_name": "meta_op_unary",
    "props": {
      "cnst": "cnst_nonconst_func",
      "type": "common_op"
    }
  },
  {
    "sons": {
      "array": 0,
      "value": 1
    },
    "name": "meta_op_push_back",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_error",
      "cnst": "cnst_error",
      "type": "common_op"
    }
  },
  {
    "comment": "require expr(); if once is true, it's require_once",
    "name": "op_require",
    "base_name": "meta_op_unary",
    "props": {
      "cnst": "cnst_error",
      "rl": "rl_error",
      "type": "common_op"
    },
    "extra_fields": {
      "once": {
        "type": "bool",
        "default": "false"
      },
      "builtin": {
        "type": "bool",
        "default": "false"
      }
    }
  },
  {
    "extra_fields": {
      "int_val": {
        "type": "int",
        "default": 0
      }
    },
    "sons": {
      "level": 0
    },
    "name": "meta_op_goto",
    "base_name": "meta_op_base"
  },
  {
    "comment": "define(name(), value())",
    "sons": {
      "name": 0,
      "value": 1
    },
    "name": "op_define",
    "base_name": "meta_op_base"
  },
  {
    "comment": "artificial vertex representing inlined define data",
    "sons": {
      "value" : 0
    },
    "name": "op_define_val",
    "base_name": "meta_op_base",
    "extra_fields": {
      "define_id": {
        "type": "DefinePtr",
        "default": "{}"
      }
    }
  },
  {
    "extras": [
      "string"
    ],
    "name": "meta_op_num",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_const",
      "cnst": "cnst_const_func",
      "type": "common_op"
    }
  },
  {
    "comment": "aftificial vertex to trigger ExprNodeRecalc for a func call with ^1 and similar dependencies",
    "name": "op_trigger_recalc_arg_ref_rule",
    "base_name": "meta_op_base",
    "extra_fields": {
      "type_hint": {
        "type": "const TypeHint *"
      },
      "func_call": {
        "type": "VertexPtr"
      }
    }
  },
  {
    "comment": "artificial placeholder expression op",
    "name": "op_empty",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "empty"
    }
  },
  {
    "comment": "integer value literal, like 32",
    "name": "op_int_const",
    "base_name": "meta_op_num",
    "props": {
      "str": "const int"
    }
  },
  {
    "comment": "floating point value literal, like 32.5",
    "name": "op_float_const",
    "base_name": "meta_op_num",
    "props": {
      "str": "const float"
    }
  },
  {
    "comment": "a simple var, like $foo; variable name is stored in str_val",
    "extras": [
      "string"
    ],
    "name": "op_var",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_var",
      "cnst": "cnst_nonconst_func",
      "type": "common_op",
      "str": "var"
    },
    "extra_fields": {
      "is_const": {
        "type": "bool",
        "default": "false"
      },
      "var_id": {
        "type": "VarPtr",
        "default": "{}"
      }
    }
  },
  {
    "comment": "string literal expression; str_val holds literal value",
    "extras": [
      "string"
    ],
    "name": "op_string",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_const",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "const string"
    }
  },
  {
    "comment": "a function name (or property name during gentree)",
    "extras": [
      "string"
    ],
    "name": "op_func_name",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_const",
      "cnst": "cnst_nonconst_func",
      "type": "common_op",
      "str": "function name"
    }
  },
  {
    "comment": "a set of operations that construct the interpolated string result",
    "name": "op_string_build",
    "base_name": "meta_op_varg",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "string build"
    },
    "ranges": {
      "args": [
        0,
        0
      ]
    }
  },
  {
    "comment": "any function (or method) call",
    "extras": [
      "string"
    ],
    "name": "op_func_call",
    "base_name": "meta_op_varg",
    "props": {
      "rl": "rl_func",
      "cnst": "cnst_func",
      "type": "common_op",
      "str": "function call"
    },
    "extra_fields": {
      "func_id": {
        "type": "FunctionPtr",
        "default": "{}"
      },
      "reifiedTs": {
        "type": "GenericsInstantiationMixin *",
        "default": "nullptr"
      }
    }
  },
  {
    "comment": "artificial op that evaluates to a CData.c_value reference",
    "name": "op_ffi_cdata_value_ref",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_other",
      "cnst": "cnst_nonconst_func",
      "type": "common_op",
      "str": "op_ffi_cdata_value_ref"
    }
  },
  {
    "comment": "artificial op that is inserted instead of FFI::addr call",
    "name": "op_ffi_addr",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_nonconst_func",
      "type": "common_op",
      "str": "ffi_addr"
    }
  },
  {
    "comment": "artificial op that is inserted instead of FFI::cast call",
    "sons": {
      "expr": {
        "id": 0
      },
      "array_size_expr": {
        "id": 1,
        "optional": true
      }
    },
    "name": "op_ffi_cast",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_nonconst_func",
      "type": "common_op",
      "str": "ffi_cast"
    },
    "extra_fields": {
      "php_type": {
        "type": "const TypeHint *",
        "default": "nullptr"
      }
    }
  },
  {
    "comment": "artificial op that implements ffi_array_get functions",
    "name": "op_ffi_array_get",
    "sons": {
      "array": 0,
      "key": 1
    },
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "ffi_array_get"
    },
    "extra_fields": {
      "c_elem_type": {
        "type": "const TypeHint *"
      }
    }
  },
  {
    "comment": "artificial op that implements ffi_array_set function",
    "name": "op_ffi_array_set",
    "sons": {
      "array": 0,
      "key": 1,
      "value": 2
    },
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "ffi_array_set"
    },
    "extra_fields": {
      "c_elem_type": {
        "type": "const TypeHint *"
      }
    }
  },
  {
    "comment": "artificial op that is inserted instead of FFI::new call",
    "name": "op_ffi_new",
    "sons": {
      "owned_flag_expr": {
        "id": 0
      },
      "array_size_expr": {
        "id": 1,
        "optional": true
      }
    },
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_other",
      "cnst": "cnst_nonconst_func",
      "type": "common_op",
      "str": "ffi_new"
    },
    "extra_fields": {
      "php_type": {
        "type": "const TypeHint *",
        "default": "nullptr"
      }
    }
  },
  {
    "comment": "artificial op that wraps FFI::load call",
    "sons": {
      "func_call": {
        "id": 0,
        "type": "op_func_call"
      }
    },
    "name": "op_ffi_load_call",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_nonconst_func",
      "type": "common_op",
      "str": "ffi_load_call"
    },
    "extra_fields": {
      "scope_name": {
        "type": "std::string"
      }
    }
  },
  {
    "comment": "()-invocation, $f(...) is actually op_invoke_call($f, ...), func_id is bound after after lambdas instantiated",
    "name": "op_invoke_call",
    "base_name": "meta_op_varg",
    "props": {
      "rl": "rl_func",
      "cnst": "cnst_func",
      "type": "common_op",
      "str": "__invoke"
    },
    "extra_fields": {
      "func_id": {
        "type": "FunctionPtr",
        "default": "{}"
      }
    }
  },
  {
    "comment": "array_map(FN, $arr) and others FN passed to built-in; FN can ref to a lambda, to __invoke method, to a function; sons are captured variables, str_val is name of function/method",
    "extras": [
      "string"
    ],
    "name": "op_callback_of_builtin",
    "base_name": "meta_op_varg",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "builtin callback"
    },
    "extra_fields": {
      "func_id": {
        "type": "FunctionPtr",
        "default": "{}"
      }
    }
  },
  {
    "comment": "instance()->prop; string field holds the name of the accessed member",
    "extras": [
      "string"
    ],
    "name": "op_instance_prop",
    "base_name": "meta_op_base",
    "sons": {
      "instance": 0
    },
    "props": {
      "rl": "rl_instance_prop",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "op_instance_prop"
    },
    "extra_fields": {
      "var_id": {
        "type": "VarPtr",
        "default": "{}"
      },
      "class_id": {
        "type": "ClassPtr",
        "default": "{}"
      },
      "access_type": {
        "type": "InstancePropAccessType",
        "default": "InstancePropAccessType::Default"
      }
    }
  },
  {
    "comment": "a list of statements",
    "name": "op_seq",
    "base_name": "meta_op_varg",
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "sequence"
    }
  },
  {
    "comment": "a comma-separated list of expressions",
    "name": "op_seq_comma",
    "base_name": "meta_op_varg",
    "props": {
      "rl": "rl_func",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "comma separated sequence"
    }
  },
  {
    "comment": "an op_seq that returns its last statement expression result",
    "name": "op_seq_rval",
    "base_name": "meta_op_varg",
    "props": {
      "rl": "rl_func",
      "cnst": "cnst_nonconst_func",
      "type": "common_op",
      "str": "seq_rval"
    }
  },
  {
    "comment": "holds op_function params in params()",
    "name": "op_func_param_list",
    "base_name": "meta_op_varg",
    "ranges": {
      "params": [
        0,
        0
      ]
    }
  },
  {
    "comment": "variadic argument: array()...",
    "name": "op_varg",
    "base_name": "meta_op_base",
    "sons": {
      "array": 0
    }
  },
  {
    "comment": "var(); or var() = default_value(); type hints and @param are stored in type_hint",
    "name": "op_func_param",
    "base_name": "meta_op_base",
    "sons": {
      "var": {
        "id": 0,
        "type": "op_var"
      },
      "default_value": {
        "id": 1,
        "optional": true,
        "virtual": true
      }
    },
    "extra_fields": {
      "type_hint": {
        "type": "const TypeHint *",
        "default": "nullptr"
      },
      "is_cast_param": {
        "type": "bool",
        "default": "false"
      }
    }
  },
  {
    "comment": "isset(expr())",
    "name": "op_isset",
    "base_name": "meta_op_xset",
    "props": {
      "rl": "rl_op",
      "str": "isset"
    }
  },
  {
    "comment": "unset(expr())",
    "name": "op_unset",
    "base_name": "meta_op_xset",
    "props": {
      "rl": "rl_common",
      "str": "unset"
    }
  },
  {
    "comment": "while (cond()) cmd()",
    "sons": {
      "cond": 0,
      "cmd": {
        "id": 1,
        "type": "op_seq"
      }
    },
    "name": "op_while",
    "base_name": "meta_op_cycle",
    "props": {
      "str": "while-loop"
    }
  },
  {
    "comment": "do cmd() while (cond())",
    "sons": {
      "cond": 1,
      "cmd": {
        "id": 0,
        "type": "op_seq"
      }
    },
    "name": "op_do",
    "base_name": "meta_op_cycle",
    "props": {
      "str": "do-loop"
    }
  },
  {
    "comment": "for (pre_cond(); cond(); post_cond()) cmd()",
    "sons": {
      "pre_cond": {
        "id": 0,
        "type": "op_seq"
      },
      "cond": 1,
      "post_cond": {
        "id": 2,
        "type": "op_seq"
      },
      "cmd": {
        "id": 3,
        "type": "op_seq"
      }
    },
    "name": "op_for",
    "base_name": "meta_op_cycle",
    "props": {
      "str": "for-loop"
    }
  },
  {
    "comment": "foreach (params()) cmd()",
    "sons": {
      "params": {
        "type": "op_foreach_param",
        "id": 0
      },
      "cmd": {
        "id": 1,
        "type": "op_seq"
      }
    },
    "name": "op_foreach",
    "base_name": "meta_op_cycle",
    "props": {
      "str": "foreach-loop"
    }
  },
  {
    "comment": "foreach header: xs() as x(); or xs() as key() => x()",
    "sons": {
      "xs": 0,
      "x": {
        "id": 1,
        "type": "op_var"
      },
      "temp_var": 2,
      "key": {
        "id": 3,
        "optional": true,
        "type": "op_var"
      }
    },
    "name": "op_foreach_param",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "foreach parameter"
    }
  },
  {
    "comment": "switch (condition()) { cases()... }",
    "sons": {
      "condition": 0,
      "condition_on_switch" : {
        "id": 1,
        "type": "op_var"
      },
      "matched_with_one_case" : {
        "id": 2,
        "type": "op_var"
      }
    },
    "name": "op_switch",
    "base_name": "meta_op_cycle",
    "props": {
      "str": "switch"
    },
    "extra_fields": {
      "kind": {
        "type": "SwitchKind"
      }
    },
    "ranges": {
      "cases": [
        3,
        0
      ]
    }
  },
  {
    "comment": "if (cond()) true_cmd(); or if (cond()) true_cmd() else false_cmd()",
    "sons": {
      "cond": 0,
      "true_cmd": {
        "id": 1,
        "type": "op_seq"
      },
      "false_cmd": {
        "id": 2,
        "optional": true,
        "type": "op_seq"
      }
    },
    "name": "op_if",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "if"
    }
  },
  {
    "comment": "break; or break level()",
    "name": "op_break",
    "base_name": "meta_op_goto",
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "break"
    }
  },
  {
    "comment": "continue; or continue level()",
    "name": "op_continue",
    "base_name": "meta_op_goto",
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "continue"
    }
  },
  {
    "comment": "case expr(): cmd()...",
    "sons": {
      "expr": 0,
      "cmd": {
        "id": 1,
        "type": "op_seq"
      }
    },
    "name": "op_case",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "case"
    }
  },
  {
    "comment": "default case of the switch with cmd() holding its statement list",
    "sons": {
      "cmd": {
        "id": 0,
        "type": "op_seq"
      }
    },
    "name": "op_default",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "default"
    }
  },
  {
    "comment": "array(args()...); or [args()...]",
    "name": "op_array",
    "base_name": "meta_op_varg",
    "props": {
      "rl": "rl_func",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "array"
    }
  },
  {
    "comment": "tuple type constructor call",
    "name": "op_tuple",
    "base_name": "meta_op_varg",
    "props": {
      "rl": "rl_func",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "tuple<>"
    }
  },
  {
    "comment": "shape type constructor call",
    "name": "op_shape",
    "base_name": "meta_op_varg",
    "props": {
      "rl": "rl_func",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "shape<>"
    }
  },
  {
    "comment": "post-processed op_set with op_list_ce (or op_array) LHS",
    "name": "op_list",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_func",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "list"
    },
    "sons": {
      "array": -1
    },
    "ranges": {
      "list": [
        0,
        -1
      ]
    }
  },
  {
    "comment": "list() assignment LHS before it was post-processed",
    "name": "op_list_ce",
    "base_name": "meta_op_base"
  },
  {
    "comment": "global statement that binds global vars to the current scope",
    "name": "op_global",
    "base_name": "meta_op_varg",
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "global"
    }
  },
  {
    "comment": "static fields or vars list",
    "name": "op_static",
    "base_name": "meta_op_varg",
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "static"
    }
  },
  {
    "comment": "return expr()",
    "name": "op_return",
    "base_name": "meta_op_base",
    "sons": {
      "expr": {
        "id": 0,
        "optional": true
      }
    },
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "return"
    }
  },
  {
    "comment": "lsh() == rhs()",
    "name": "op_eq2",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_func_op",
      "str": "eq2",
      "description": "=="
    }
  },
  {
    "comment": "lsh() === rhs()",
    "name": "op_eq3",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_func_op",
      "str": "equals",
      "description": "==="
    }
  },
  {
    "comment": "lsh() <= rhs()",
    "name": "op_le",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "<=",
      "description": "<="
    }
  },
  {
    "comment": "lsh() < rhs()",
    "name": "op_lt",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "<",
      "description": "<"
    }
  },
  {
    "comment": "lsh() <=> rhs()",
    "name": "op_spaceship",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_func_op",
      "str": "spaceship",
      "description": "<=>"
    }
  },
  {
    "comment": "lsh() + rhs()",
    "name": "op_add",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "+"
    }
  },
  {
    "comment": "lsh() - rhs()",
    "name": "op_sub",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "-"
    }
  },
  {
    "comment": "lsh() . rhs()",
    "name": "op_concat",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "concatenation"
    }
  },
  {
    "comment": "lsh() * rhs()",
    "name": "op_mul",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "*"
    }
  },
  {
    "comment": "lsh() / rhs()",
    "name": "op_div",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_func_op",
      "str": "divide"
    }
  },
  {
    "comment": "lsh() % rhs()",
    "name": "op_mod",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_func_op",
      "str": "modulo"
    }
  },
  {
    "comment": "lsh() ** rhs()",
    "name": "op_pow",
    "base_name": "meta_op_binary",
    "props": {
      "cnst": "cnst_const_func",
      "fixity": "right_opp",
      "rl": "rl_op",
      "type": "binary_func_op",
      "str": "power"
    }
  },
  {
    "comment": "lsh() xor rhs()",
    "name": "op_log_xor_let",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "^"
    }
  },
  {
    "comment": "lsh() and rhs()",
    "name": "op_log_and_let",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "&&"
    }
  },
  {
    "comment": "lsh() or rhs()",
    "name": "op_log_or_let",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "||"
    }
  },
  {
    "comment": "lsh() && rhs()",
    "name": "op_log_and",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "&&"
    }
  },
  {
    "comment": "lsh() || rhs()",
    "name": "op_log_or",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "||"
    }
  },
  {
    "comment": "lsh() ^ rhs()",
    "name": "op_xor",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "^"
    }
  },
  {
    "comment": "lsh() | rhs()",
    "name": "op_or",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "|"
    }
  },
  {
    "comment": "lsh() & rhs()",
    "name": "op_and",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "&"
    }
  },
  {
    "comment": "lsh() >> rhs()",
    "name": "op_shr",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": ">>"
    }
  },
  {
    "comment": "lsh() << rhs()",
    "name": "op_shl",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "<<"
    }
  },
  {
    "comment": "error suppression operator: @expr()",
    "name": "op_noerr",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_other",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "NOERR"
    }
  },
  {
    "comment": "-expr()",
    "name": "op_minus",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "prefix_op",
      "str": " - "
    }
  },
  {
    "comment": "+expr()",
    "name": "op_plus",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "prefix_op",
      "str": " + "
    }
  },
  {
    "comment": "lhs() => rhs()",
    "alias": {
      "value": "rhs",
      "key": "lhs"
    },
    "name": "op_double_arrow",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "fixity": "right_opp",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "@op_double_arrow"
    }
  },
  {
    "comment": "LHS list(...) elements: key() => var(); for implicit keys the key() is auto-calculated op_int_const",
    "alias": {
      "var": "rhs",
      "key": "lhs"
    },
    "name": "op_list_keyval",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_other",
      "fixity": "right_opp",
      "cnst": "cnst_const_func",
      "type": "binary_op",
      "str": "@op_list_keyval"
    }
  },
  {
    "comment": "a base type for all modifying assignment operations",
    "name": "op_set_modify",
    "base_name": "meta_op_binary"
  },
  {
    "comment": "a simple assignment: lhs() = rhs()",
    "name": "op_set",
    "base_name": "op_set_modify",
    "props": {
      "rl": "rl_set",
      "fixity": "right_opp",
      "cnst": "cnst_nonconst_func",
      "type": "binary_op",
      "str": "="
    }
  },
  {
    "comment": "lhs() += rhs()",
    "name": "op_set_add",
    "base_name": "op_set_modify",
    "props": {
      "cnst": "cnst_nonconst_func",
      "base_op": "op_add",
      "str": "+=",
      "rl": "rl_set",
      "fixity": "right_opp",
      "type": "binary_op"
    }
  },
  {
    "comment": "lhs() -= rhs()",
    "name": "op_set_sub",
    "base_name": "op_set_modify",
    "props": {
      "cnst": "cnst_nonconst_func",
      "base_op": "op_sub",
      "str": "-=",
      "rl": "rl_set",
      "fixity": "right_opp",
      "type": "binary_op"
    }
  },
  {
    "comment": "lhs() *= rhs()",
    "name": "op_set_mul",
    "base_name": "op_set_modify",
    "props": {
      "cnst": "cnst_nonconst_func",
      "base_op": "op_mul",
      "str": "*=",
      "rl": "rl_set",
      "fixity": "right_opp",
      "type": "binary_op"
    }
  },
  {
    "comment": "lhs() /= rhs()",
    "name": "op_set_div",
    "base_name": "op_set_modify",
    "props": {
      "cnst": "cnst_nonconst_func",
      "base_op": "op_div",
      "str": "divide_self",
      "rl": "rl_set",
      "fixity": "right_opp",
      "type": "binary_func_op"
    }
  },
  {
    "comment": "lhs() %= rhs()",
    "name": "op_set_mod",
    "base_name": "op_set_modify",
    "props": {
      "cnst": "cnst_nonconst_func",
      "base_op": "op_mod",
      "str": "modulo_self",
      "rl": "rl_set",
      "fixity": "right_opp",
      "type": "binary_func_op"
    }
  },
  {
    "comment": "lhs() **= rhs()",
    "name": "op_set_pow",
    "base_name": "op_set_modify",
    "props": {
      "base_op": "op_pow",
      "cnst": "cnst_nonconst_func",
      "fixity": "right_opp",
      "rl": "rl_set",
      "type": "binary_func_op",
      "str": "power_self"
    }
  },
  {
    "comment": "lhs() &= rhs()",
    "name": "op_set_and",
    "base_name": "op_set_modify",
    "props": {
      "cnst": "cnst_nonconst_func",
      "base_op": "op_and",
      "str": "&=",
      "rl": "rl_set",
      "fixity": "right_opp",
      "type": "binary_op"
    }
  },
  {
    "comment": "lhs() |= rhs()",
    "name": "op_set_or",
    "base_name": "op_set_modify",
    "props": {
      "cnst": "cnst_nonconst_func",
      "base_op": "op_or",
      "str": "|=",
      "rl": "rl_set",
      "fixity": "right_opp",
      "type": "binary_op"
    }
  },
  {
    "comment": "lhs() ^= rhs()",
    "name": "op_set_xor",
    "base_name": "op_set_modify",
    "props": {
      "cnst": "cnst_nonconst_func",
      "base_op": "op_xor",
      "str": "^=",
      "rl": "rl_set",
      "fixity": "right_opp",
      "type": "binary_op"
    }
  },
  {
    "comment": "lhs() .= rhs()",
    "name": "op_set_dot",
    "base_name": "op_set_modify",
    "props": {
      "cnst": "cnst_nonconst_func",
      "base_op": "op_concat",
      "str": "append",
      "rl": "rl_set",
      "fixity": "right_opp",
      "type": "binary_func_op"
    }
  },
  {
    "comment": "lhs() >>= rhs()",
    "name": "op_set_shr",
    "base_name": "op_set_modify",
    "props": {
      "cnst": "cnst_nonconst_func",
      "base_op": "op_shr",
      "str": ">>=",
      "rl": "rl_set",
      "fixity": "right_opp",
      "type": "binary_op"
    }
  },
  {
    "comment": "lhs() <<= rhs()",
    "name": "op_set_shl",
    "base_name": "op_set_modify",
    "props": {
      "cnst": "cnst_nonconst_func",
      "base_op": "op_shl",
      "str": "<<=",
      "rl": "rl_set",
      "fixity": "right_opp",
      "type": "binary_op"
    }
  },
  {
    "comment": "lhs() ??= rhs(); where lhs() does not contain op_func_call",
    "name": "op_set_null_coalesce",
    "base_name": "op_set_modify",
    "props": {
      "base_op": "op_null_coalesce",
      "cnst": "cnst_nonconst_func",
      "fixity": "right_opp",
      "rl": "rl_set",
      "type": "binary_op",
      "str": "\\?\\?="
    }
  },
  {
    "comment": "cond() ? true_expr() : false_expr()",
    "sons": {
      "true_expr": 1,
      "cond": 0,
      "false_expr": 2
    },
    "name": "op_ternary",
    "base_name": "meta_op_base",
    "props": {
      "cnst": "cnst_const_func",
      "description": "? ... : ...",
      "str": "ternary operator",
      "rl": "rl_op",
      "fixity": "right_opp",
      "type": "ternary_op"
    }
  },
  {
    "comment": "lhs() ?? rhs()",
    "name": "op_null_coalesce",
    "base_name": "meta_op_binary",
    "props": {
      "cnst": "cnst_const_func",
      "description": "??",
      "str": "null_coalesce",
      "rl": "rl_op",
      "fixity": "right_opp",
      "type": "binary_func_op"
    }
  },
  {
    "comment": "~expr()",
    "name": "op_not",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "prefix_op",
      "str": "~"
    }
  },
  {
    "comment": "!expr()",
    "name": "op_log_not",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "prefix_op",
      "str": "!"
    }
  },
  {
    "comment": "++expr()",
    "name": "op_prefix_inc",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op_l",
      "cnst": "cnst_nonconst_func",
      "type": "prefix_op",
      "str": "++"
    }
  },
  {
    "comment": "--expr()",
    "name": "op_prefix_dec",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op_l",
      "cnst": "cnst_nonconst_func",
      "type": "prefix_op",
      "str": "--"
    }
  },
  {
    "comment": "&expr()",
    "name": "op_addr",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "prefix_op",
      "str": "&$..."
    }
  },
  {
    "comment": "(c_type)expr()",
    "name": "op_ffi_php2c_conv",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_nonconst_func",
      "type": "conv_op",
      "str": "ffi_php2c"
    },
    "extra_fields": {
      "c_type": {
        "type": "const TypeHint *"
      },
      "simple_dst": {
        "type": "bool",
        "default": "true"
      }
    }
  },
  {
    "comment": "(php_type)expr()",
    "name": "op_ffi_c2php_conv",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_nonconst_func",
      "type": "conv_op",
      "str": "ffi_c2php"
    },
    "extra_fields": {
      "php_type": {
        "type": "const TypeHint *",
        "default": "nullptr"
      }
    }
  },
  {
    "comment": "(int)expr(); or intval(expr())",
    "name": "op_conv_int",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "conv_op",
      "str": "f$intval"
    }
  },
  {
    "comment": "lvalue form of op_conv_int",
    "name": "op_conv_int_l",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_other",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "intval_ref"
    }
  },
  {
    "comment": "(float)expr(); or (double)expr(); or floatval(expr())",
    "name": "op_conv_float",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "conv_op",
      "str": "f$floatval"
    }
  },
  {
    "comment": "(string)expr(); or strval(expr())",
    "name": "op_conv_string",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "conv_op",
      "str": "f$strval"
    }
  },
  {
    "comment": "lvalue form of op_conv_string",
    "name": "op_conv_string_l",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_other",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "strval_ref"
    }
  },
  {
    "comment": "(array)expr(); or arrayval(expr())",
    "name": "op_conv_array",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "conv_op",
      "str": "f$arrayval"
    }
  },
  {
    "comment": "lvalue form of op_conv_array",
    "name": "op_conv_array_l",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_other",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "arrayval_ref"
    }
  },
  {
    "comment": "(object)expr()",
    "name": "op_conv_object",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "conv_op",
      "str": "(object)"
    }
  },
  {
    "comment": "(bool)expr(); or boolval(expr())",
    "name": "op_conv_bool",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "conv_op",
      "str": "f$boolval"
    }
  },
  {
    "comment": "fake vertex we need it to forbid casts of classes to mixed in context of internal functions(from functions.txt)",
    "name": "op_conv_mixed",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "conv_op",
      "str": "mixed"
    }
  },
  {
    "comment": "converts expression to mixed as (mixed) $x, used only for returns of global switches/main functions/disable return warning",
    "name": "op_force_mixed",
    "base_name": "op_conv_mixed"
  },
  {
    "comment": "artificial op that converts expr() to tp_regexp",
    "name": "op_conv_regexp",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "conv_op",
      "str": "regexp"
    }
  },
  {
    "comment": "not_false(expr())",
    "name": "op_conv_drop_false",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "conv_op",
      "str": "check_not_false"
    }
  },
  {
    "comment": "not_null(expr())",
    "name": "op_conv_drop_null",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "conv_op",
      "str": "check_not_null"
    }
  },
  {
    "comment": "expr()++",
    "name": "op_postfix_inc",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op_l",
      "cnst": "cnst_nonconst_func",
      "type": "postfix_op",
      "str": "++"
    }
  },
  {
    "comment": "expr()--",
    "name": "op_postfix_dec",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op_l",
      "cnst": "cnst_nonconst_func",
      "type": "postfix_op",
      "str": "--"
    }
  },
  {
    "comment": "array()[key()]; or array()[]",
    "sons": {
      "array": 0,
      "key": {
        "id": 1,
        "optional": true
      }
    },
    "name": "op_index",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_index",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "$...[.]"
    }
  },
  {
    "comment": "optimized form of array()[] = value()",
    "name": "op_push_back",
    "base_name": "meta_op_push_back",
    "props": {
      "str": "push_back"
    }
  },
  {
    "comment": "like meta_op_push_back, but the result is not being discarded",
    "name": "op_push_back_return",
    "base_name": "meta_op_push_back",
    "props": {
      "str": "push_back_return"
    }
  },
  {
    "comment": "lowered form of array()[key()] = value()",
    "sons": {
      "array": 0,
      "key": 1,
      "value": 2
    },
    "name": "op_set_value",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_error",
      "cnst": "cnst_error",
      "type": "common_op",
      "str": "set_value"
    }
  },
  {
    "comment": "false literal",
    "name": "op_false",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_const",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "false"
    }
  },
  {
    "comment": "true literal",
    "name": "op_true",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_const",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "true"
    }
  },
  {
    "comment": "null literal",
    "name": "op_null",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_const",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "null"
    }
  },
  {
    "comment": "a placeholder op for an empty lvalue",
    "name": "op_lvalue_null",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_var",
      "cnst": "cnst_nonconst_func",
      "type": "common_op",
      "str": "lvalue null"
    }
  },
  {
    "comment": "artificial op that performs std::move(expr())",
    "name": "op_move",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_nonconst_func",
      "type": "conv_op",
      "str": "std::move"
    }
  },
  {
    "comment": "defined(expr())",
    "name": "op_defined",
    "base_name": "meta_op_base",
    "sons": {
      "expr": 0
    },
    "props": {
      "rl": "rl_func",
      "cnst": "cnst_nonconst_func",
      "type": "common_op",
      "str": "defined"
    }
  },
  {
    "comment": "catch (type_declaration var()) { cmd() }",
    "sons": {
      "var": {
        "id": 0,
        "type": "op_var"
      },
      "cmd": {
        "id": 1,
        "type": "op_seq"
      }
    },
    "name": "op_catch",
    "base_name": "meta_op_base",
    "extra_fields": {
      "type_declaration": {
        "type": "std::string"
      },
      "exception_class": {
        "type": "ClassPtr"
      }
    },
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "catch"
    }
  },
  {
    "comment": "try { try_cmd()... } catch_list<op_catch>()...; catches_all is true if all exceptions are handled by this try statement",
    "sons": {
      "try_cmd": {
        "id": 0,
        "type": "op_seq"
      }
    },
    "ranges": {
      "catch_list": [
        1,
        0
      ]
    },
    "name": "op_try",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "try"
    },
    "extra_fields": {
      "catches_all": {
        "type": "bool",
        "default": "true"
      }
    }
  },
  {
    "comment": "artificial op for a fork call; func_call() contains a fork argument",
    "sons": {
      "func_call": {
        "id": 0,
        "type": "op_func_call"
      }
    },
    "name": "op_fork",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_func",
      "cnst": "cnst_nonconst_func",
      "type": "common_op",
      "str": "fork"
    }
  },
  {
    "comment": "artificial op that wraps async function call, optionally with save_var() for LHS",
    "sons": {
      "func_call": {
        "id": 0,
        "type": "op_func_call"
      },
      "save_var": {
        "id": 1,
        "type": "op_var",
        "optional": true
      }
    },
    "name": "op_async",
    "base_name": "meta_op_base",
    "props": {
      "type": "common_op",
      "str": "async"
    }
  },
  {
    "comment": "throw exception()",
    "name": "op_throw",
    "base_name": "meta_op_base",
    "sons": {
      "exception": 0
    },
    "props": {
      "rl": "rl_common",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "throw"
    },
    "extra_fields": {
      "class_id": {
        "type": "ClassPtr",
        "default": "{}"
      }
    }
  },
  {
    "comment": "artificial op that doesn't produce any code",
    "name": "op_none",
    "base_name": "meta_op_base"
  },
  {
    "comment": "clone expr()",
    "name": "op_clone",
    "base_name": "meta_op_unary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "clone"
    },
    "extra_fields": {
      "class_id": {
        "type": "ClassPtr",
        "default": "{}"
      }
    }
  },
  {
    "comment": "artificial op that holds allocated class info",
    "name": "op_alloc",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "common_op",
      "str": "new"
    },
    "extra_fields": {
      "allocated_class": {
        "type": "ClassPtr"
      },
      "allocated_class_name": {
        "type": "std::string"
      }
    }
  },
  {
    "comment": "lhs() instanceof rhs()",
    "name": "op_instanceof",
    "base_name": "meta_op_binary",
    "props": {
      "rl": "rl_op",
      "cnst": "cnst_const_func",
      "type": "binary_func_op",
      "str": "instanceof"
    },
    "extra_fields": {
      "derived_class": {
        "type": "ClassPtr"
      }
    }
  },
  {
    "comment": "artificial op that holds phpdoc @var info inside a function (not above a field)",
    "sons": {
      "var": {
        "id": 0,
        "type": "op_var"
      }
    },
    "name": "op_phpdoc_var",
    "base_name": "meta_op_base",
    "props": {
      "rl": "rl_other",
      "cnst": "cnst_not_func",
      "type": "common_op",
      "str": "@var"
    },
    "extra_fields": {
      "type_hint": {
        "type": "const TypeHint *",
        "default": "nullptr"
      }
    }
  }
]
